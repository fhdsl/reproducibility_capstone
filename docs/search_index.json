[["index.html", "Making Science Reproducible – a Capstone Project Course About this Course", " Making Science Reproducible – a Capstone Project Course July, 2025 About this Course This course is part of a series of courses created for the Informatics Technology for Cancer Research (ITCR) Training Network (ITN). The ITN is a collaborative effort of researchers around the United States that supports cancer informatics and data science training through resources, technology, and events. This initiative is funded by the following grant: National Cancer Institute (NCI) UE5 CA254170. Our courses feature tools developed by ITCR Investigators and make it easier for principal investigators, scientists, analysts, and trainees to integrate cancer informatics into their workflows. Please see our website at itcrtraining.org for more information. Except where otherwise indicated, the contents of this course are available for use under the Creative Commons Attribution 4.0 license. You are free to adapt and share the work, but you must give appropriate credit, provide a link to the license, and indicate if changes were made. Sample attribution: Making Science Reproducible – a Capstone Project Course by Fred Hutchinson Data Science Lab (CC-BY 4.0). You can download the illustrations by clicking here. "],["introduction.html", "Chapter 1 Introduction 1.1 Motivation 1.2 Target Audience 1.3 Curriculum 1.4 Objectives 1.5 How to use the course 1.6 Where do you need to invest?", " Chapter 1 Introduction 1.1 Motivation Cancer research in the 21st century is increasingly data-driven, with researchers generating and analyzing vast amounts of genomic, proteomic, imaging, and clinical data. The ability to effectively manage, analyze, and share these complex datasets has become as crucial as traditional laboratory skills. However, many cancer researchers find themselves working with computational tools and workflows that were not developed using robust software engineering practices. These tools often suffer from poor documentation, lack of version control, inadequate testing, and limited interoperability. Such limitations hinder collaboration, impede scalability, and make it difficult to reproduce results reliably. The modern cancer informatics landscape demands not just analytical skills, but also proficiency in reproducible computational practices. Research has shown that computational analyses are often difficult or impossible to reproduce without direct contact with the original researchers (Beaulieu-Jones and Greene 2017). This reproducibility crisis extends beyond academic concerns—it directly impacts the translation of research findings into clinical applications and the overall efficiency of cancer research efforts. 1.2 Target Audience The course is intended for cancer researchers, bioinformaticians, and data scientists who work with computational analyses in cancer research contexts and want to enhance the reproducibility, efficiency, and shareability of their work. This capstone course builds on foundational concepts from the following ITCR Training Network’s courses: Intro to Reproducibility in Cancer Informatics Advanced Reproducibility in Cancer Informatics Containers for Scientists GitHub Automation for Scientists Students should be comfortable with basic GitHub operations, including creating repositories, making commits, and opening pull requests before beginning this capstone. This capstone course is written for individuals who: Conduct computational analyses for cancer research, including genomics, proteomics, imaging, or clinical data analysis. Have completed the ITN reproducibility courses mentioned above. Want to put the reproducibility skill sets together and get more practice doing this in a “real world” setting. 1.3 Curriculum The course covers practical application of containerization and automation technologies specifically tailored for cancer informatics workflows. Unlike introductory courses that focus on individual concepts, this capstone emphasizes integration and real-world application of multiple technologies working together. 1.4 Objectives Assessment Approach: The capstone uses a practical, project-based assessment model where students work with a provided computational sandbox environment to complete real-world tasks. Rather than traditional exams, students demonstrate mastery by successfully implementing containerized workflows and automated pipelines that pass automated evaluation criteria. Custom Container Development Assignment - Students create Docker containers to support specific cancer analysis requirements, demonstrating understanding of containerization principles and bioinformatics software management. Working with GitHub Secrets Assignment – Students create a personal access token, store the token as a GitHub secret in a repository and access that secret in a GitHub Actions workflow, displaying application of best practices in security when handling sensitive information. Automated Workflow Implementation Assignment - Students create GitHub Actions that automatically execute and validate cancer data analysis pipelines, showing proficiency in continuous integration concepts and workflow automation. Each assignment utilizes automated evaluation systems that provide immediate feedback and validation codes upon successful completion, simulating real-world development environments where code must pass automated testing before deployment. Goal of this course: Enable cancer researchers to create, maintain, and share reproducible computational workflows that meet the evolving standards of modern cancer informatics while enhancing collaboration and accelerating scientific discovery. What is not the goal: This course does not aim to teach cancer biology, statistical analysis methods, or introductory programming concepts. Students are expected to bring domain expertise and basic computational skills to the course, focusing instead on learning to apply advanced reproducibility technologies to their existing research workflows. 1.5 How to use the course This capstone course is designed as a hands-on, practical experience that builds directly on the foundational knowledge from previous ITCR Training Network courses. Students should approach the course with an active learning mindset, ready to experiment, troubleshoot, and iterate on their solutions. Working with the Course Sandbox: The course utilizes a GitHub-based sandbox environment that simulates real-world research collaboration workflows. Students will work with the template repository, create branches for different assignments, and receive automated feedback through pull request evaluations. This approach mirrors modern software development practices and prepares students for collaborative research environments. Integration Focus: Each assignment builds on previous work and integrates multiple technologies. Students should be prepared to synthesize knowledge from containerization, automation, version control, and domain-specific cancer informatics concepts. The goal is to create holistic solutions rather than demonstrate isolated technical skills. Real-world Application: Throughout the course, students are encouraged to consider how the techniques they’re learning apply to their own research contexts. The assignments use cancer informatics examples, but the principles and technologies transfer to a wide range of computational research domains. We also recommend that students leverage the broader ITCR Training Network community and resources to enhance their learning experience and build lasting professional connections in the cancer informatics community. 1.6 Where do you need to invest? This course aims to help you apply what we have learned in the previous courses to a real world application. What you build in this capstone is completely up to you, but for your own benefit we suggest you try to make something you will use in your work beyond this specialization. Think about work on GitHub that you are doing manually, or a project where you are struggling to easily reproduce the results. Those may be ripe opportunities for you to build something. However, keep in mind that it’s OK to start small and build up to these goals as you learn. Use a few minutes for introspective reflection about where you are spending a lot of time and effort to reproduce something that could use some reproducibility investment (like a Github Action or Docker image). Consider attempting to develop such reproducibility investments for these projects in your upcoming assignments. References "],["setting-up-for-this-course.html", "Chapter 2 Setting up for this course 2.1 Phase 1: Creating Your Repository from Template 2.2 Phase 2: Local Setup and Cloning 2.3 Phase 3: Branch Creation and Workflow 2.4 Phase 4: Completion 2.5 Your Setup is Complete…. What are the Next Steps? 2.6 Troubleshooting Common Issues", " Chapter 2 Setting up for this course 2.1 Phase 1: Creating Your Repository from Template You will need to use a template repository on GitHub that we made for this course to have all the necessary pieces. 2.1.1 Step 1: Access the Course Template Go to github.com and make sure you are logged in Navigate to the course sandbox template repository Look for the Use this template green button at the top of the repository page Important: Do NOT fork the repository - you must use the template option 2.1.2 Step 2: Configure Your New Repository Click Use this template and select the “Create a new repository” option (if needed). Fill out the repository creation form:      Include all branches: Leave unchecked (we only need the main branch)      Owner: Choose an owner (e.g., your-username, if needed)      Repository name: Choose a meaningful name (e.g., your-username-capstone-sandbox)      Description: Add a brief description of your capstone project      Visibility: Set to Public (required for the automated evaluation system to work) 2.1.3 Step 3: Create Your Repository Click Create repository Wait for GitHub to finish creating your repository and verify completion      • Note: You’ll be redirected to your new repository page      Verify: The repository should show your username as the owner and contain all the template files 2.2 Phase 2: Local Setup and Cloning For this course you may use whatever git client (GitHub Desktop, GitKraken, etc) you are most comfortable with, or no git client at all. If you need a recap on how to file pull requests remember you can return to the other courses in this series for reference, particularly the Advanced Reproducibility course. 2.2.1 Step 4: Clone Your Repository Option A: Using GitHub Desktop Open GitHub Desktop Click “Clone a repository from the Internet” Select your repository from the list or paste the URL you copied Choose a local path where you want to store the repository Click “Clone” Option B: Using a command-line interface Alternatively, you can use a command-line interface (e.g., Command Prompt, PowerShell, the Command Line) rather than GitHub Desktop. If you need to install Git, GitHub provides a guide for various platforms. Instructions within these command-line interface sections will be using “bash”. Copy the repository URL: On your repository page, click the Code green button Copy the HTTPS URL (should look like: https://github.com/yourusername/your-repo-name.git) Clone the repository, using the HTTPS URL you’ve just copied: # Navigate to where you want to store the project cd ~/Desktop # or your preferred location # Clone the repository git clone https://github.com/yourusername/your-repo-name.git # Navigate into the repository cd your-repo-name 2.3 Phase 3: Branch Creation and Workflow 2.3.1 Step 5: Create Your Branch for the Docker Assignment You may name your working branch whatever you like for each assignment. The examples/instructions use the name docker-assignment for the first example. Option A: Using GitHub Desktop Click on the “Current branch” dropdown (shows “main”) Click “New branch” Name your branch: docker-assignment Click “Create branch” Option B: Using a command-line interface # Create and switch to a new branch for the docker assignment git checkout -b docker-assignment # Verify you&#39;re on the new branch git branch # The asterisk (*) should be next to &quot;docker-assignment&quot; 2.4 Phase 4: Completion 2.4.1 Step 6: Collect a workflow URL Navigate to github.com, specifically your repository/copy of the capstone sandbox. Navigate to the .github/workflows directory. Click on one of the workflow files that are present there. Copy the URL from your web browser for this workflow file.      • The URL will look like: https://github.com/your-username/your-repository-name/blob/main(or-your-branch)/.github/workflows/file_name.yml If you are taking the course on Coursera: Submit your Coursera Quiz Go to your Coursera Graded Assignment (“Setting Up”). Paste the URL you copied in Step 6. Submit the quiz to get credit for your work. icons from icons8 2.5 Your Setup is Complete…. What are the Next Steps? This setup process creates the foundation for the Docker and GitHub Action capstone assignments, which will follow a similar pattern: Create a branch → Make changes → Commit changes → Push to GitHub → Open a PR → Receive evaluation (→ iterate if needed). The automated evaluation system depends on this workflow, so following these steps precisely is crucial for getting your validation codes! Note that the validation codes are really only needed if you are participating in this capstone as a part of the Coursera or Leanpub platforms (for certification). If you are not taking this course for certification, there is no structure in place to verify the validation code you receive. 2.5.1 Reminders of Best Practices for Success while Working with GitHub Use one branch per assignment - keeps work organized Write descriptive commit messages - helps track your progress Regularly push your work - protects your work and enables evaluation Use clear titles and descriptions for pull requests - will help you and your collaborators know what the work in the branch is Don’t merge your pull request before you get the validation code - outside of this assignment, wait for approval from a team member or collaborator Monitor automated feedback - respond to or handle issues identified by evaluation promptly 2.6 Troubleshooting Common Issues 2.6.1 “Repository not found” when cloning: Check that the repository is public Verify the URL you’ve copy/pasted is correct Ensure you have access to the repository 2.6.2 “Permission denied” when pushing: Check that you’re pushing to your own repository (not the template) Verify your Git credentials are set up correctly Try using a personal access token instead of password 2.6.3 Automated evaluation not running: Ensure your pull request is against the main branch Check that required files are in the correct locations Verify the repository is public "],["building-a-docker-image.html", "Chapter 3 Building a Docker Image 3.1 Phase 1: Repository Setup and Planning 3.2 Phase 2: Dockerfile Development 3.3 Phase 3: Testing and Iteration 3.4 Phase 4: Troubleshooting and Refinement 3.5 Phase 5: Completion 3.6 Suggestions for Troubleshooting and Best Practices", " Chapter 3 Building a Docker Image 3.1 Phase 1: Repository Setup and Planning 3.1.1 Step 1: Set Up Your Working Environment Navigate to your capstone sandbox repository. Locate the Docker_Assignment/docker/Dockerfile - you will be making changes within this file. Important: Don’t change the name or location of this file. 3.1.2 Step 2: Switch to Your Working Branch (if needed) Verify that you’re on the branch you created during the set up instructions.      • The example used the name docker-assignment. Option A: Using GitHub Desktop Check the “Current Branch” Dropdown on the top left of the screen. Use the menu to select the branch if you are not on the branch you expect to be on. Option B: Using a command-line interface git status # The first line of the output of this command will report what branch you are on... # On branch docker-assignment If you are not on the branch you expect to be on, you can “checkout” or “switch” your branch. 3.1.3 Step 3: Analyze Your Capstone Project Needs In general, you may already have a reason for building a custom docker image, or a specific set of tools you wish to package together. The following questions and guidelines are helpful for real-world development of a custom docker image. Here are some situations you might find yourself in where a docker image is helpful: • You are building a Github action and need a specialized group of packages. • You are building an analysis that you need a collaborator to run. • You are building software you want to be reliable in its deployment. Questions to ask yourself: • What programming languages you’re using (R, Python, etc.) • What packages/libraries your analysis scripts require • What types of security concerns does this project have? • Are there publicly available docker images that could cover your needs already? For this capstone project specifically, you will create a custom docker image with very little guidance as to what packages it will include. Think about a couple of packages that are helpful in your day to day work, and build a docker image with that in mind. 3.2 Phase 2: Dockerfile Development 3.2.1 Step 4: Examine the Base Setup Open Docker_Assignment/docker/Dockerfile Look on Docker Hub for what base image best suits your needs – what’s the smallest image you can get away with that is from a verified source? Understand what’s already included in the base image already. If you’re not sure what’s already included, consider inspecting the image with Docker Desktop      • Note: You don’t need to add a package that’s already there.      • Will it work with R or Python packages or both? Once you’ve chosen a base image, add it to your Dockerfile. 3.2.2 Step 5: Add Packages Incrementally Start by adding just one or two additional packages to your Dockerfile Use the templates from the course:      • For R packages: RUN Rscript -e \"install.packages('packagename')\"      • For Python packages: RUN pip3 install packagename Add comments explaining what each package does 3.2.3 Step 6: Build Locally If developing locally (e.g., working through Command Line or GitHub Desktop, rather than on github.com directly), make sure the Docker application is running, and test your Dockerfile with: cd Docker_Assignment/docker docker build . -t my-capstone-image Iterate fixing any build errors and re-building before pushing to GitHub. This saves time and GitHub Actions usage. If you’re not developing locally, opening a pull request with changes to your Dockerfile on GitHub should trigger an evaluation action as explained in the next phase. 3.3 Phase 3: Testing and Iteration 3.3.1 Step 7: Open Your Pull Request Commit your Dockerfile changes to your branch Push the branch to GitHub Open a pull request from your branch to the main branch Changes to the Docker_Assignment/docker/Dockerfile triggers the Docker Assignment Eval test. Can you guess why? Automatic Evaluation after changes to the Dockerfile The capstone sandbox is using a GitHub Action with a trigger that is defined by changes to the Dockerfile within a pull request wanting to merge to main to evaluate the Dockerfile. 3.3.2 Step 8: Monitor the Automated Testing &amp; Interpret the Results On github.com, within your pull request, watch for the Docker Assignment Eval check to start running. This GitHub Action will attempt to build your Dockerfile. Wait for it to complete. It will comment on your PR whether it successfully built or not. If you don’t see the comment try refreshing your browser      • Success: You’ll get a validation code in the comment      • Failure: You’ll get error messages explaining what went wrong. Read the error messages carefully - they contain clues for fixing issues Interpret the results and proceed accordingly:      If the test’s comment provides a validation code, skip to Phase 5.      If the test’s comment contains error messages, visit Phase 4: Troubleshooting and Refinement of these instructions. 3.4 Phase 4: Troubleshooting and Refinement 3.4.1 Step 9: Debug Build Failures Common issues to check: Typos in package names Missing dependencies (install system packages before language packages). Google or a code trained LLM (e.g., Phind) can be helpful for determining missing dependencies. Incorrect syntax in RUN commands Base image doesn’t support your installation method 3.4.2 Step 10: Iterate Until Success Make changes to your Dockerfile on your branch Commit and push changes Each push will trigger a new test run Keep refining until you get a successful build! 3.4.3 Step 11: Merge Your Pull Request Once you’ve received a validation code (congrats!), you can treat this like a team member approved your pull request. Go ahead and merge the PR and delete your branch so that your Dockerfile will be on the main branch, available for use in a later assignment if you want it. Click the green Merge pull request button. Adjust the commit message and extended description as you see fit. Click the green Confirm merge button. Finally, after you see “Pull Request successfully merged and closed displayed, you can click the gray Delete branch button. 3.5 Phase 5: Completion If you are taking the course on Coursera: Collect Your Validation Code Copy the validation code from the pull request comment earlier in the thread/above where you’ve merged and deleted your branch. You’ll need the code in order to submit your quiz. Important: Make sure it’s a real validation code, not an error message or status code used to identify an error. Submit Your Quiz Go to your Coursera Graded Assignment (“Building a Docker Image”) Paste the validation code Submit the quiz to get credit for your work icons from icons8 3.6 Suggestions for Troubleshooting and Best Practices Remember, this assignment is designed to give you hands-on experience with the container building process. The automated testing system provides immediate feedback, making it easier to learn through iteration rather than getting everything perfect on the first try. 3.6.1 Start Simple Begin with just the most essential packages for your analysis You can always add more in subsequent iterations A working simple image is better than a broken complex one Reference tips from the Containers for Scientists course as needed. 3.6.2 Leverage the Automated Testing The GitHub Action is your friend - it provides immediate feedback Don’t be afraid to make multiple attempts Each unsuccessful iteration and new error message teaches you something about container building 3.6.3 Read Error Messages Carefully Error messages may contain the exact solution you need to fix your problem Look for phrases like “package not found” or “missing dependency” Google specific error messages if they’re unclear Copy and paste the error code and include any relevant context to a code trained LLM (e.g., Phind) for additional help. 3.6.4 Document Your Process Add comments to your Dockerfile explaining your choices Comments &amp; documentation help you remember your reasoning if you need to modify it later and may make debugging easier "],["making-a-github-secret.html", "Chapter 4 Making a GitHub Secret 4.1 Phase 0: Understanding GitHub Secrets 4.2 Phase 1: Creating Your Personal Access Token 4.3 Phase 2: Storing the Secret in Your Repository 4.4 Phase 3: Testing Your Secret 4.5 Phase 4: Troubleshooting and Refinement 4.6 Phase 5: Completion", " Chapter 4 Making a GitHub Secret 4.1 Phase 0: Understanding GitHub Secrets 4.1.1 What Are GitHub Secrets? GitHub Secrets are encrypted environment variables stored securely in your repository. They allow you to store sensitive information (like usernames, API keys, tokens, passwords) without exposing them in your code. Secrets are only accessible to GitHub Actions during workflow runs and appear as * in logs. This assignment teaches you a fundamental skill for secure automation in research environments 4.1.2 Why Personal Access Tokens Matter Personal Access Tokens (PATs) provide secure authentication for GitHub Actions. They’re an alternative to passwords for GitHub authentication. They allow automated workflows to perform actions that require permissions (like creating issues, pushing to repositories, etc.). In research contexts, PATs enable automated data sharing, publication workflows, and collaborative tools Important: PATs should be treated like passwords - never share them publicly Often, and in this assignment, you will begin by generating a personal access token in GitHub settings and storing that as a repository secret that can be utilized within workflows/GitHub Actions. But, as mentioned above, GitHub secrets do not always have to be personal access tokens. 4.1.3 Best Practices and Security Considerations 4.1.3.1 Token Management Use descriptive names for tokens to track their purpose Set appropriate expiration dates - shorter is more secure Regularly audit and rotate tokens in production environments Revoke unused tokens to minimize security exposure 4.1.3.2 Secret Storage Best Practices Use specific, descriptive names for secrets Apply principle of least privilege - only grant necessary permissions Never log or print secrets in your workflows Regularly review who has access to repository secrets 4.1.3.3 Research Context Applications API keys for data sources (e.g., cancer databases, genomic repositories) Authentication for computing clusters or cloud services Credentials for automated publication or preprint systems Tokens for collaborative tools and notification systems 4.2 Phase 1: Creating Your Personal Access Token 4.2.1 Step 1: Navigate to GitHub Token Settings Go to your GitHub profile (click your profile picture in the top right) Click “Settings” from the dropdown menu (you will see a gear icon ) Scroll down to “Developer settings” in the left sidebar (at the bottom) Click “Personal access tokens” Select “Tokens (classic)” from the submenu Navigation path: Profile → Settings → Developer settings → Personal access tokens → Tokens (classic) 4.2.2 Step 2: Generate New Token Click “Generate new token” Select “Generate new token (classic)” GitHub may ask for your password or a 2-factor authenticator (2FA) code - enter it to continue You’ll be taken to the token creation page 4.2.3 Step 3: Configure Your Token Add a descriptive note:      • Use something like “Secret Storage Assignment”      • This helps you remember what this token is for later Set expiration:      • For this assignment, you can set it to 30 days or custom      • In real research, consider the security vs. convenience trade-off Select scopes (permissions):      • Check “repo” - this gives full repository access      • For this assignment, “repo” scope is sufficient      • If using a GitHub secret in a GitHub Action/workflow, you may need to select “workflow” as well.      • In production, use the minimum required permissions 4.2.4 Step 4: Generate and Copy Token Scroll to bottom and click the green Generate token button. CRITICAL: Copy the token immediately - GitHub will only show it once (perhaps keep the window open as you copy it) The token will look like: ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Warning: If you navigate away without copying the token, you’ll need to create a new one! To create a new one, follow Steps 1-4 (within Phase 1) again. 4.3 Phase 2: Storing the Secret in Your Repository 4.3.1 Step 5: Navigate to Repository Settings Go to your capstone sandbox repository (not your personal settings) Click the “Settings” tab at the top of the repository page In the left sidebar, find “Secrets and variables” Click “Actions” under “Secrets and variables” Repository navigation: Repository → Settings → Secrets and variables → Actions 4.3.2 Step 6: Create New Repository Secret Click the green New repository secret button Enter the secret details:      Name: ASSIGNMENT_SECRET      Secret: Paste your personal access token from Step 4 Click the green Add secret button Your repository secret must be named ASSIGNMENT_SECRET exactly. It is case sensitive. 4.3.3 Step 7: Verify Secret Creation You should see ASSIGNMENT_SECRET listed in your repository secrets The value will show as “Updated X seconds ago” but won’t display the actual token If you need to update the secret, click the secret name and choose “Update” 4.4 Phase 3: Testing Your Secret Because you’ve made changes to your repository settings, but not changes to the files within the repository, we can’t open a Pull Request to run an automatic test/evaluation of your work. Instead, we’ll have to manually trigger the GitHub Action Evaluator Test. In order to report success or failure, the test will open an Issue in your GitHub repo (since there is no open Pull Request to comment on). 4.4.1 Step 8: Trigger the Evaluation Action Navigate to the “Actions” tab in your repository Look for “GitHub Secret Evaluation” in the workflows list on the left Click on “GitHub Secret Evaluation” Click the “Run workflow” dropdown (you may need to select branch “main”) Click the green Run workflow button again to confirm 4.4.2 Step 9: Monitor the Evaluation &amp; Interpret the Results The evaluation will take a few moments to check if your secret exists and is valid. Don’t worry if it takes a minute - the system needs to verify everything is configured correctly Watch for the workflow to start running (you’ll see a yellow circle, then green checkmark or red X) Navigate to the “Issues” tab in your repository Look for a new issue created by the evaluation system Click on the issue to see detailed results Interpret the results and proceed accordingly:      If the issue title indicates success, and the description of the issue contains a validation, skip to Phase 5.      If the issue title indicates failure, and the description of the issue contains error messages, visit Phase 4: Troubleshooting and Refinement of these instructions. 4.5 Phase 4: Troubleshooting and Refinement 4.5.1 Step 10: Debug Failures 4.5.1.1 Secret Not Found: Verify: Check the secret name: Must be exactly ASSIGNMENT_SECRET Verify secret location:      Must be in repository secrets as described in Step 6, not personal settings      Secret is stored in the correct sandbox repository (not fhdsl/capstone-sandbox but instead your own copy) Re-create if needed: Delete and recreate the secret with correct name 4.5.1.2 “Invalid token” Error Verify: Token was copied correctly (no extra spaces) Token hasn’t expired Token has ‘repo’ scope permissions Token was generated for the correct GitHub account What to do to fix: Generate a new PAT: Your token may have expired or been created incorrectly Check scopes: Ensure “repo” permission is selected Update the secret: Replace the old token with the new one 4.5.1.3 Workflow Doesn’t Run In this case, if the workflow doesn’t run, it won’t create an issue reporting on success/failure or you may not be able to find it to manually trigger it in Step 8. Ensure: You’re triggering from the correct repository You’re selecting the main branch The workflow file (secret_assignment_eval.yml) exists in .github/workflows/ You have permissions to run workflows 4.5.2 Step 11: Re-running Evaluation If you need to fix issues and re-test: Make necessary corrections (recreate secret, new token, etc.) Return to the Actions tab Run the “GitHub Secret Evaluation” workflow again Check for a new issue with updated results 4.6 Phase 5: Completion If you are taking this course on Coursera: Collect Your Validation Code Once your evaluation action succeeds, copy the validation code from the Issue description. You’ll need the code in order to submit your quiz. Submit Your Quiz on Coursera Go to your Coursera Graded Assignment (“Making a GitHub Secret”) Paste the validation code exactly as provided in the issue Submit the quiz to get credit for your work icons from icons8 4.6.1 Clean Up (Optional but Recommended) After completing the assignment: Consider revoking the PAT if you don’t plan to use it further Delete the secret if it’s no longer needed Reflect on/Document what you learned about secret management This assignment teaches a crucial skill for modern computational research: secure credential management. In real research environments, you’ll use these same techniques to store API keys for cancer databases, authentication tokens for computing clusters, and credentials for automated research workflows. The ability to securely manage secrets enables sophisticated automation while maintaining security standards required for sensitive cancer research data. "],["building-a-github-action.html", "Chapter 5 Building a GitHub Action 5.1 Phase 1: Repository Setup and Planning 5.2 Phase 2: GitHub Action Development 5.3 Phase 3: Testing and Iteration 5.4 Phase 4: Troubleshooting and Refinement 5.5 Phase 6: Completion 5.6 Suggestions for Troubleshooting and Best Practices", " Chapter 5 Building a GitHub Action 5.1 Phase 1: Repository Setup and Planning 5.1.1 Step 1: Set Up Your Working Environment Navigate to your capstone sandbox repository Locate the GitHub_Action_Assignment.yml file within the GitHub_Action_Assignment directory - this is your starting template Review the existing template to understand what’s already provided Important: Do not change the filename from GitHub_Action_Assignment.yml. Leave the name exactly as it is. You will be moving the file’s location, but do not change its name. 5.1.2 Step 2: Create Your Working Branch In order to isolate your work and enable the automated evaluation system this sandbox uses, you will create a new working branch. Create a new branch for this assignment (e.g., github-action-assignment or gha-build) Switch to this branch before making any changes 5.1.3 Step 3: Move File to Correct Location GitHub Actions must be in the .github/workflows/ directory for Github to recognize them as a GitHub Action. Move GitHub_Action_Assignment.yml to .github/workflows/GitHub_Action_Assignment.yml Critical: The file must be in this exact location for GitHub to recognize it as a workflow file (and for this assignment to automatically evaluate your GitHub Action). 5.1.4 Step 4: Plan Your GitHub Action While learning, it can be really helpful to pick an action that produces something that you can visually inspect (e.g., a report or plot) because if it is generated and looks how you expect, you can confirm that your GitHub Action is successful and doesn’t have a silent failure occurring in the background. Decide what useful task your GitHub Action will perform - Ideas for useful actions:      Run automated tests on your capstone code      Generate reports or documentation      Check code quality or formatting      Create data visualizations      Send notifications when certain conditions are met      Validate data files or configurations You never want to put sensitive PHI or PII on GitHub, even in a private repository. You will want to limit the size of any data files you are putting on GitHub unless you have large file storage (GitLFS) capabilities. So if you want to run a report, create a visualization, or validate a data file, then perhaps make a small toy dataset. 5.2 Phase 2: GitHub Action Development 5.2.1 Step 5: Understand the Template Structure Open GitHub_Action_Assignment.yml and examine the existing structure Identify the key components:      name: - What your action is called      on: - When it should trigger      jobs: - What it should do      job-name: - an identifier of the job specifically      runs-on: - What environment to use 5.2.2 Step 6: Define Your Action’s Purpose Choose a meaningful trigger (on:):      pull_request: - Runs when PRs are opened/updated (good for testing)      push: - Runs when code is pushed to specific branches      workflow_dispatch: - Allows manual triggering (useful for development)      schedule: - Runs on a time schedule (e.g., once a week) Design your job steps:      Start with actions/checkout@v4 to get your repository files      Add steps that accomplish your chosen task      Include error handling and status checks      It’s important to name steps so that you can access and check outputs of those steps. Consider and possibly emulate one of these common design strategies for various tasks. Notice how they fill out the key components and outline where the task steps will be filled in: For Code Quality/Testing: name: Code Quality Check on: pull_request jobs: quality-check: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - name: Run quality checks run: | # Your quality check commands here echo &quot;Running code quality checks...&quot; For Data Analysis: name: Automated Analysis on: workflow_dispatch jobs: analyze: runs-on: ubuntu-latest container: image: jhudsl/ottr_python:main # Example with R and Python steps: - uses: actions/checkout@v4 - name: Run analysis run: | # Your analysis commands here For Documentation: name: Generate Documentation on: push jobs: docs: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - name: Generate docs run: | # Documentation generation commands Fill out the GitHub_Action_Assignment.yml, including the key components, and the steps of the action (the task you chose), under run: |. While on your branch, add any needed files (e.g., scripts or toy data) to your copy of the sandbox repository so that your GitHub Action can access them. 5.3 Phase 3: Testing and Iteration 5.3.1 Step 7: Open Your Pull Request Key: This step triggers the GHA Assignment Eval test Commit your changes to your branch. Push the branch to GitHub. Open a pull request from your branch to main. 5.3.2 Step 8: Monitor Automated Evaluation &amp; Interpret Evaluation Results Watch for the GHA Assignment Eval check to start running This evaluator will test whether your GitHub Action runs successfully. The evaluator checks for common issues and provides guidance. Wait for it to complete and comment on your PR      • Success: You’ll receive a validation code in the PR comment      • Failure: You’ll get specific error messages and troubleshooting tips Interpret the results and proceed accordingly:      If the test’s comment provides a validation code, skip to Phase 5.      If the test’s comment contains error messages, visit Phase 4: Troubleshooting and Refinement of these instructions. 5.4 Phase 4: Troubleshooting and Refinement 5.4.1 Step 9: Debug Common Issues Common issues to check: YAML syntax errors: Check indentation, colons, and spacing File location errors: Ensure file is in .github/workflows/ Permission errors: May need to add GitHub secrets or tokens (see the GitHub Secrets Assignment for more information if necessary) Missing dependencies: Check if your chosen environment has required software Silent failures: Verify your action actually does what you expect You’ll find specific error messages in the actions logs. Check them out! 5.4.2 Step 10: Iterate Until Success Make changes to your GitHub_Action_Assignment.yml file on your branch Commit and push changes to trigger new evaluation runs Keep refining based on feedback until you get an action that runs successfully 5.5 Phase 6: Completion If you are taking the course on Coursera: Collect Your Validation Code Once your GitHub Action runs successfully, copy the validation code from the PR comment. Keep this code safe for your quiz submission. Submit Your Quiz Go to your Coursera Graded Assignment (“Building a GitHub Action”) Paste the validation code when prompted Submit the quiz to get credit for your work icons from icons8 5.6 Suggestions for Troubleshooting and Best Practices Remember: This assignment builds on both the containers knowledge (for choosing appropriate environments) and the GitHub Actions automation concepts. The goal is to demonstrate your understanding of continuous integration principles by creating something that automatically improves or validates your capstone project. 5.6.1 Start Simple and Build Up Begin with a basic action that you know will work. Your action should be useful but not overly complex. Focus on demonstrating GitHub Actions concepts rather than building production software. Test early and often to catch issues quickly. Add complexity gradually, testing each addition. Use marketplace actions: Leverage existing actions when possible. 5.6.2 Use Course Knowledge Reference information from the GitHub Automation for Scientists course as needed. Reference YAML examples from course exercises Apply containers knowledge: Choose appropriate runs-on: environment Consider using Docker containers if you need specific software Reference container images from Docker Hub if needed Apply automation principles: Ensure your action fails appropriately when something goes wrong Include meaningful output and logging Use environment variables and secrets when needed. (Remember you may need to add the “workflow” scope to your personal access token for this assignment.) 5.6.3 Leverage the Automated Testing The automated evaluator provides immediate feedback Don’t be afraid to make multiple attempts - each iteration teaches you something Read the evaluator’s comments carefully for specific guidance 5.6.4 Read Error Messages Carefully Error messages (in the actions logs) often contain the exact solution Check the logs: Go to the Actions tab and examine detailed output Print debugging info: Use echo commands to verify assumptions Google specific error messages if they’re unclear Copy and paste the error code and include any relevant context to a code trained LLM (e.g., Phind) for additional help. The automated evaluation system is designed to help you learn through iteration, so embrace the feedback loop and keep refining your action until it works reliably! "],["about-the-authors.html", "About the Authors", " About the Authors These credits are based on our course contributors table guidelines.     Credits Names Pedagogy Lead Content Instructor(s) Candace Savonen Lecturer(s) Candace Savonen Content Contributor(s) Kate Isaac, Carrie Wright Content Editor(s)/Reviewer(s) Carrie Wright, Kate Isaac Production Content Publisher(s) Carrie Wright, Kate Isaac, Candace Savonen Content Publishing Reviewer(s) Carrie Wright Technical Course Publishing Engineer(s) Helped with the code for the technical aspects related to the specific course generation Template Publishing Engineers Candace Savonen, Carrie Wright, Ava Hoffman Publishing Maintenance Engineer Candace Savonen Technical Publishing Stylists Carrie Wright, Ava Hoffman, Candace Savonen Package Developers (ottrpal) Candace Savonen, Ava Hoffman, Howard Baek, Kate Isaac, Carrie Wright, John Muschelli Art and Design Figure Artist(s) Carrie Wright, Kate Isaac Videographer(s) Candace Savonen Funding Funder(s) Institution/individual who funded course including grant number Funding Staff Staff members who help with funding   ## ─ Session info ─────────────────────────────────────────────────────────────── ## setting value ## version R version 4.3.2 (2023-10-31) ## os Ubuntu 22.04.4 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz Etc/UTC ## date 2025-07-29 ## pandoc 3.1.1 @ /usr/local/bin/ (via rmarkdown) ## ## ─ Packages ─────────────────────────────────────────────────────────────────── ## package * version date (UTC) lib source ## bookdown 0.41 2024-10-16 [1] CRAN (R 4.3.2) ## bslib 0.6.1 2023-11-28 [1] RSPM (R 4.3.0) ## cachem 1.0.8 2023-05-01 [1] RSPM (R 4.3.0) ## cli 3.6.2 2023-12-11 [1] RSPM (R 4.3.0) ## devtools 2.4.5 2022-10-11 [1] RSPM (R 4.3.0) ## digest 0.6.34 2024-01-11 [1] RSPM (R 4.3.0) ## ellipsis 0.3.2 2021-04-29 [1] RSPM (R 4.3.0) ## evaluate 0.23 2023-11-01 [1] RSPM (R 4.3.0) ## fastmap 1.1.1 2023-02-24 [1] RSPM (R 4.3.0) ## fs 1.6.3 2023-07-20 [1] RSPM (R 4.3.0) ## glue 1.7.0 2024-01-09 [1] RSPM (R 4.3.0) ## htmltools 0.5.7 2023-11-03 [1] RSPM (R 4.3.0) ## htmlwidgets 1.6.4 2023-12-06 [1] RSPM (R 4.3.0) ## httpuv 1.6.14 2024-01-26 [1] RSPM (R 4.3.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.3.0) ## jsonlite 1.8.8 2023-12-04 [1] RSPM (R 4.3.0) ## knitr 1.48 2024-07-07 [1] CRAN (R 4.3.2) ## later 1.3.2 2023-12-06 [1] RSPM (R 4.3.0) ## lifecycle 1.0.4 2023-11-07 [1] RSPM (R 4.3.0) ## magrittr 2.0.3 2022-03-30 [1] RSPM (R 4.3.0) ## memoise 2.0.1 2021-11-26 [1] RSPM (R 4.3.0) ## mime 0.12 2021-09-28 [1] RSPM (R 4.3.0) ## miniUI 0.1.1.1 2018-05-18 [1] RSPM (R 4.3.0) ## pkgbuild 1.4.3 2023-12-10 [1] RSPM (R 4.3.0) ## pkgload 1.3.4 2024-01-16 [1] RSPM (R 4.3.0) ## profvis 0.3.8 2023-05-02 [1] RSPM (R 4.3.0) ## promises 1.2.1 2023-08-10 [1] RSPM (R 4.3.0) ## purrr 1.0.2 2023-08-10 [1] RSPM (R 4.3.0) ## R6 2.5.1 2021-08-19 [1] RSPM (R 4.3.0) ## Rcpp 1.0.12 2024-01-09 [1] RSPM (R 4.3.0) ## remotes 2.4.2.1 2023-07-18 [1] RSPM (R 4.3.0) ## rlang 1.1.4 2024-06-04 [1] CRAN (R 4.3.2) ## rmarkdown 2.25 2023-09-18 [1] RSPM (R 4.3.0) ## sass 0.4.8 2023-12-06 [1] RSPM (R 4.3.0) ## sessioninfo 1.2.2 2021-12-06 [1] RSPM (R 4.3.0) ## shiny 1.8.0 2023-11-17 [1] RSPM (R 4.3.0) ## stringi 1.8.3 2023-12-11 [1] RSPM (R 4.3.0) ## stringr 1.5.1 2023-11-14 [1] RSPM (R 4.3.0) ## urlchecker 1.0.1 2021-11-30 [1] RSPM (R 4.3.0) ## usethis 2.2.3 2024-02-19 [1] RSPM (R 4.3.0) ## vctrs 0.6.5 2023-12-01 [1] RSPM (R 4.3.0) ## xfun 0.48 2024-10-03 [1] CRAN (R 4.3.2) ## xtable 1.8-4 2019-04-21 [1] RSPM (R 4.3.0) ## yaml 2.3.8 2023-12-11 [1] RSPM (R 4.3.0) ## ## [1] /usr/local/lib/R/site-library ## [2] /usr/local/lib/R/library ## ## ────────────────────────────────────────────────────────────────────────────── "],["references.html", "Chapter 6 References", " Chapter 6 References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
